# 어댑터 패턴(Adapter Pattern)

> 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있다. <br />
어댑터 패턴에는 객체 어댑터와 클래스 어댑터가 있으며 이 장에서 설명하는 패턴은 객체 어댑터다. <br />
클래스 어댑터는 어댑터가 Target과 Adaptee를 다중 상속한다. 

어댑터는 인터페이스를 클라이언트에서 원하는 인터페이스로 바꾸는 역할을 한다.

<img width="241" alt="image" src="https://user-images.githubusercontent.com/60346043/168071303-e96afd32-e8ef-4ca7-a403-77b781e3a8c8.png">



<img width="631" alt="image" src="https://user-images.githubusercontent.com/60346043/168070312-14f3d590-ab44-4dd8-9166-1090793bd75a.png">

## Enumeration을 Iterator에 적응 시키기 

상황) 새로 작성하는 코드는 Iterator를 사용하지만 특정 패키지의 경우 호환성 이슈 때문에 Enumeration를 사용해야 한다면?

```java
public Class DoSometing<T> {
  private T iter;

  public DoSomething(T iter) {
    this.iter = iter;
  }

  public void doing() {
    if (iter instanceof Enumeration) {
      if (iter.hasMoreElement()) {
        iter.nextElemnt();
      }
    } else {
      if (iter.hasNext()) {
        iter.next();
      }
    }
  }
}
```

<img width="415" alt="image" src="https://user-images.githubusercontent.com/60346043/168078704-997f196b-b780-4f0f-94c4-5c01adea19fe.png">


```java
public class EnumerationIterator implements Iterator<Object> {
  Enumeration<?> enumeration;

  public EnumerationIterator(Enumeration<?> enumeration) {
    this.enumeration = enumeration;
  }

  public boolean hasNext() {
    return enumeration.hasMoreElements();
  }

  public boolean next() {
    return enumeration.nextElement();
  } 

  public void remove() {
    throw new UnsupportedOperationException();
  }
}
```

사용하는 클래스에서는 주입받는 iterable 객체가 Iterator인지 Enumeration인지 알 필요가 없다.
 
```java
public class DoSometing {
  private Iterator iter;
  public DoSomething(Iterator iter) {
    this.iter = iter;
  }

  public void doing() {
    if (iter.hasNext()) {
      iter.next();
    }
  }
}
```